<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>„Éá„ÉÉ„Çµ„É≥„Çπ„Ç±„Éº„É´ - Drawing Scale</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #video {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #controls {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            max-width: 90%;
            display: block;
        }

        #controls.hidden {
            display: none;
        }

        #controlsContent {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 15px;
            max-height: 60vh;
            overflow-y: auto;
        }

        #toggleControls {
            width: 100%;
            padding: 12px;
            font-size: 18px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 100, 100, 0.9);
            color: white;
            cursor: pointer;
            font-weight: 600;
            text-align: center;
        }

        #openControls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 101;
            width: 50px;
            height: 50px;
            padding: 0;
            font-size: 24px;
            border: none;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        #openControls.visible {
            display: flex;
        }

        #captureButton {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            width: 70px;
            height: 70px;
            padding: 0;
            font-size: 32px;
            border: 4px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.4);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        #captureButton:active {
            transform: translateX(-50%) scale(0.9);
        }

        #actionButtons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            justify-content: center;
            padding: 10px;
            width: 100%;
        }

        #actionButtons button {
            padding: 16px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            width: 100%;
            min-height: 50px;
        }

        button, select {
            padding: 12px 20px;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        button:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.7);
        }

        select {
            min-width: 120px;
        }

        #error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 59, 48, 0.95);
            color: white;
            padding: 20px 30px;
            border-radius: 12px;
            display: none;
            text-align: center;
            max-width: 80%;
            z-index: 200;
        }

        #imagePreview {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 300;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #imagePreview.visible {
            display: flex;
        }

        #imagePreview img {
            max-width: 90%;
            max-height: 70vh;
            border-radius: 8px;
        }

        #imagePreview .instructions {
            color: white;
            font-size: 16px;
            margin-top: 20px;
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            max-width: 80%;
        }

        #imagePreview button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        label {
            color: white;
            font-size: 14px;
            font-weight: 500;
        }

        input[type="range"] {
            width: 150px;
        }

        input[type="color"] {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" playsinline autoplay></video>
        <canvas id="overlay"></canvas>
    </div>

    <button id="openControls">‚öôÔ∏è</button>
    <button id="captureButton">üì∑</button>

    <div id="controls">
        <div id="controlsContent">
            <div class="control-group">
                <label>„Çπ„Ç±„Éº„É´„Çø„Ç§„Éó:</label>
                <select id="scaleType">
                    <option value="grid">„Ç∞„É™„ÉÉ„Éâ</option>
                    <option value="ruler">ÂÆöË¶è</option>
                    <option value="quarters">4ÂàÜÂâ≤ÔºàÂçÅÂ≠óÔºâ</option>
                    <option value="quartersGrid">4ÂàÜÂâ≤16„Éû„Çπ</option>
                    <option value="thirds">‰∏âÂàÜÂâ≤Ê≥ï</option>
                    <option value="golden">ÈªÑÈáëÊØî</option>
                    <option value="none">„Å™„Åó</option>
                </select>
            </div>

            <div class="control-group">
                <label>„Éï„Ç©„Éº„Éû„ÉÉ„Éà:</label>
                <select id="format">
                    <option value="none">„Å™„Åó</option>
                    <option value="square">Ê≠£ÊñπÂΩ¢ (1:1)</option>
                    <option value="4:3">4:3</option>
                    <option value="3:2">3:2</option>
                    <option value="16:9">16:9</option>
                    <option value="9:16">9:16 (Á∏¶)</option>
                    <option value="a4">A4 (210:297)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Ëâ≤:</label>
                <input type="color" id="scaleColor" value="#00ff00">
            </div>

            <div class="control-group">
                <label>ÈÄèÊòéÂ∫¶:</label>
                <input type="range" id="opacity" min="0" max="100" value="70">
            </div>
        </div>

        <div id="actionButtons">
            <button id="switchCamera">„Ç´„É°„É©ÂàáÊõø</button>
            <button id="fullscreen">„Éï„É´„Çπ„ÇØ„É™„Éº„É≥</button>
        </div>

        <button id="toggleControls">‚úï Èñâ„Åò„Çã</button>
    </div>

    <div id="error"></div>

    <div id="imagePreview">
        <img id="previewImage" src="" alt="ÊíÆÂΩ±„Åó„ÅüÁîªÂÉè">
        <div class="instructions">
            üì± ÁîªÂÉè„ÇíÈï∑Êäº„Åó„Åó„Å¶„ÄåÂÜôÁúü„Å´ËøΩÂä†„Äç„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ
        </div>
        <button id="closePreview">Èñâ„Åò„Çã</button>
    </div>

    <script>
        const video = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const ctx = overlay.getContext('2d');
        const errorDiv = document.getElementById('error');
        const imagePreviewDiv = document.getElementById('imagePreview');
        const previewImage = document.getElementById('previewImage');
        const closePreviewBtn = document.getElementById('closePreview');

        const scaleTypeSelect = document.getElementById('scaleType');
        const formatSelect = document.getElementById('format');
        const colorInput = document.getElementById('scaleColor');
        const opacityInput = document.getElementById('opacity');
        const switchCameraBtn = document.getElementById('switchCamera');
        const captureBtn = document.getElementById('captureButton');
        const fullscreenBtn = document.getElementById('fullscreen');
        const toggleControlsBtn = document.getElementById('toggleControls');
        const openControlsBtn = document.getElementById('openControls');
        const controlsDiv = document.getElementById('controls');

        let currentStream = null;
        let facingMode = 'environment'; // 'user' for front camera, 'environment' for back camera

        // Initialize camera
        async function initCamera() {
            try {
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }

                const constraints = {
                    video: {
                        facingMode: facingMode,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: false
                };

                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;

                video.onloadedmetadata = () => {
                    resizeOverlay();
                };

            } catch (err) {
                showError('„Ç´„É°„É©„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + err.message);
            }
        }

        // Resize overlay to match container
        function resizeOverlay() {
            overlay.width = window.innerWidth;
            overlay.height = window.innerHeight;
            drawScale();
        }

        // Draw scale overlay
        function drawScale() {
            ctx.clearRect(0, 0, overlay.width, overlay.height);

            const color = colorInput.value;
            const opacity = opacityInput.value / 100;

            // Convert hex to rgba
            const r = parseInt(color.substr(1, 2), 16);
            const g = parseInt(color.substr(3, 2), 16);
            const b = parseInt(color.substr(5, 2), 16);

            // Draw format overlay first and get the active drawing area
            const bounds = drawFormat(r, g, b, opacity);

            // Draw scale type within the bounds
            const scaleType = scaleTypeSelect.value;
            if (scaleType === 'none') return;

            // Set stroke style for scale lines (after drawFormat)
            const strokeStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 2;

            switch (scaleType) {
                case 'grid':
                    drawGrid(bounds);
                    break;
                case 'ruler':
                    drawRuler(bounds);
                    break;
                case 'quarters':
                    drawQuarters(bounds);
                    break;
                case 'quartersGrid':
                    drawQuartersGrid(bounds);
                    break;
                case 'thirds':
                    drawThirds(bounds);
                    break;
                case 'golden':
                    drawGoldenRatio(bounds);
                    break;
            }
        }

        function drawGrid(bounds) {
            const { x, y, width, height } = bounds;
            const gridSize = Math.min(width, height) / 10; // Auto-calculate grid size

            // Vertical lines
            for (let i = gridSize; i < width; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + height);
                ctx.stroke();
            }

            // Horizontal lines
            for (let i = gridSize; i < height; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, y + i);
                ctx.lineTo(x + width, y + i);
                ctx.stroke();
            }
        }

        function drawRuler(bounds) {
            const { x, y, width, height } = bounds;
            const spacing = Math.min(width, height) / 10;

            // Top ruler
            for (let i = 0; i < width; i += spacing / 5) {
                const tickHeight = (Math.abs(i % spacing) < 0.01) ? 40 : 20;
                ctx.beginPath();
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + tickHeight);
                ctx.stroke();
            }

            // Left ruler
            for (let i = 0; i < height; i += spacing / 5) {
                const tickWidth = (Math.abs(i % spacing) < 0.01) ? 40 : 20;
                ctx.beginPath();
                ctx.moveTo(x, y + i);
                ctx.lineTo(x + tickWidth, y + i);
                ctx.stroke();
            }
        }

        function drawQuarters(bounds) {
            const { x, y, width, height } = bounds;

            // Vertical center line
            ctx.beginPath();
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width / 2, y + height);
            ctx.stroke();

            // Horizontal center line
            ctx.beginPath();
            ctx.moveTo(x, y + height / 2);
            ctx.lineTo(x + width, y + height / 2);
            ctx.stroke();
        }

        function drawQuartersGrid(bounds) {
            const { x, y, width, height } = bounds;

            // Draw 3 vertical lines (creating 4 columns)
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x + (width * i / 4), y);
                ctx.lineTo(x + (width * i / 4), y + height);
                ctx.stroke();
            }

            // Draw 3 horizontal lines (creating 4 rows)
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x, y + (height * i / 4));
                ctx.lineTo(x + width, y + (height * i / 4));
                ctx.stroke();
            }
        }

        function drawThirds(bounds) {
            const { x, y, width, height } = bounds;

            // Vertical lines
            ctx.beginPath();
            ctx.moveTo(x + width / 3, y);
            ctx.lineTo(x + width / 3, y + height);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x + width * 2 / 3, y);
            ctx.lineTo(x + width * 2 / 3, y + height);
            ctx.stroke();

            // Horizontal lines
            ctx.beginPath();
            ctx.moveTo(x, y + height / 3);
            ctx.lineTo(x + width, y + height / 3);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x, y + height * 2 / 3);
            ctx.lineTo(x + width, y + height * 2 / 3);
            ctx.stroke();
        }

        function drawGoldenRatio(bounds) {
            const { x, y, width, height } = bounds;
            const phi = 1.618;

            // Vertical lines
            ctx.beginPath();
            ctx.moveTo(x + width / phi, y);
            ctx.lineTo(x + width / phi, y + height);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x + width - width / phi, y);
            ctx.lineTo(x + width - width / phi, y + height);
            ctx.stroke();

            // Horizontal lines
            ctx.beginPath();
            ctx.moveTo(x, y + height / phi);
            ctx.lineTo(x + width, y + height / phi);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x, y + height - height / phi);
            ctx.lineTo(x + width, y + height - height / phi);
            ctx.stroke();
        }

        function drawFormat(r, g, b, opacity) {
            const format = formatSelect.value;

            // Get video's actual display position and size
            const videoRect = video.getBoundingClientRect();
            const videoDisplayWidth = videoRect.width;
            const videoDisplayHeight = videoRect.height;
            const videoX = (overlay.width - videoDisplayWidth) / 2;
            const videoY = (overlay.height - videoDisplayHeight) / 2;

            if (format === 'none') {
                // Return full video display bounds (no scaling for format=none)
                return { x: videoX, y: videoY, width: videoDisplayWidth, height: videoDisplayHeight };
            }

            let targetAspect;
            switch (format) {
                case 'square':
                    targetAspect = 1; // 1:1
                    break;
                case '4:3':
                    targetAspect = 4 / 3;
                    break;
                case '3:2':
                    targetAspect = 3 / 2;
                    break;
                case '16:9':
                    targetAspect = 16 / 9;
                    break;
                case '9:16':
                    targetAspect = 9 / 16;
                    break;
                case 'a4':
                    targetAspect = 210 / 297;
                    break;
                default:
                    const scaledWidth = videoDisplayWidth * 0.85;
                    const scaledHeight = videoDisplayHeight * 0.85;
                    const scaledX = videoX + (videoDisplayWidth - scaledWidth) / 2;
                    const scaledY = videoY + (videoDisplayHeight - scaledHeight) / 2;
                    return { x: scaledX, y: scaledY, width: scaledWidth, height: scaledHeight };
            }

            // Calculate format at 85% of video size
            const baseWidth = videoDisplayWidth * 0.85;
            const baseHeight = videoDisplayHeight * 0.85;
            const currentAspect = baseWidth / baseHeight;

            let formatWidth, formatHeight;
            if (currentAspect > targetAspect) {
                // Base is wider than target format
                formatHeight = baseHeight;
                formatWidth = baseHeight * targetAspect;
            } else {
                // Base is taller than target format
                formatWidth = baseWidth;
                formatHeight = baseWidth / targetAspect;
            }

            // Center the format rectangle within video display area
            const x = videoX + (videoDisplayWidth - formatWidth) / 2;
            const y = videoY + (videoDisplayHeight - formatHeight) / 2;

            // Draw semi-transparent overlay outside the format area
            ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.7})`;

            // Top overlay
            ctx.fillRect(0, 0, overlay.width, y);
            // Bottom overlay
            ctx.fillRect(0, y + formatHeight, overlay.width, overlay.height - y - formatHeight);
            // Left overlay
            ctx.fillRect(0, y, x, formatHeight);
            // Right overlay
            ctx.fillRect(x + formatWidth, y, overlay.width - x - formatWidth, formatHeight);

            // Draw format border
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, formatWidth, formatHeight);

            // Return the format bounds for scale drawing
            return { x: x, y: y, width: formatWidth, height: formatHeight };
        }

        function captureImage() {
            try {
                // Get the current format bounds
                const format = formatSelect.value;
                const videoWidth = video.videoWidth;
                const videoHeight = video.videoHeight;

                let captureX = 0, captureY = 0, captureWidth = videoWidth, captureHeight = videoHeight;

                if (format !== 'none') {
                    // Calculate format bounds (same logic as drawFormat)
                    let targetAspect;
                    switch (format) {
                        case 'square':
                            targetAspect = 1;
                            break;
                        case '4:3':
                            targetAspect = 4 / 3;
                            break;
                        case '3:2':
                            targetAspect = 3 / 2;
                            break;
                        case '16:9':
                            targetAspect = 16 / 9;
                            break;
                        case '9:16':
                            targetAspect = 9 / 16;
                            break;
                        case 'a4':
                            targetAspect = 210 / 297;
                            break;
                        default:
                            targetAspect = null;
                    }

                    if (targetAspect) {
                        const currentAspect = videoWidth / videoHeight;
                        if (currentAspect > targetAspect) {
                            captureHeight = videoHeight;
                            captureWidth = videoHeight * targetAspect;
                        } else {
                            captureWidth = videoWidth;
                            captureHeight = videoWidth / targetAspect;
                        }
                        captureX = (videoWidth - captureWidth) / 2;
                        captureY = (videoHeight - captureHeight) / 2;
                    }
                }

                // Create a temporary canvas for capture
                const captureCanvas = document.createElement('canvas');
                captureCanvas.width = captureWidth;
                captureCanvas.height = captureHeight;
                const captureCtx = captureCanvas.getContext('2d');

                // Draw the video frame (cropped to format area)
                captureCtx.drawImage(
                    video,
                    captureX, captureY, captureWidth, captureHeight,
                    0, 0, captureWidth, captureHeight
                );

                // Draw the overlay (scale lines) on top
                const scaleType = scaleTypeSelect.value;
                if (scaleType !== 'none') {
                    const color = colorInput.value;
                    const opacity = opacityInput.value / 100;
                    const r = parseInt(color.substr(1, 2), 16);
                    const g = parseInt(color.substr(3, 2), 16);
                    const b = parseInt(color.substr(5, 2), 16);

                    captureCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    captureCtx.lineWidth = 2;

                    const bounds = { x: 0, y: 0, width: captureWidth, height: captureHeight };

                    switch (scaleType) {
                        case 'grid':
                            drawGridOnCanvas(captureCtx, bounds);
                            break;
                        case 'ruler':
                            drawRulerOnCanvas(captureCtx, bounds);
                            break;
                        case 'quarters':
                            drawQuartersOnCanvas(captureCtx, bounds);
                            break;
                        case 'quartersGrid':
                            drawQuartersGridOnCanvas(captureCtx, bounds);
                            break;
                        case 'thirds':
                            drawThirdsOnCanvas(captureCtx, bounds);
                            break;
                        case 'golden':
                            drawGoldenRatioOnCanvas(captureCtx, bounds);
                            break;
                    }
                }

                // Convert to data URL and show preview
                const dataUrl = captureCanvas.toDataURL('image/png');
                previewImage.src = dataUrl;
                imagePreviewDiv.classList.add('visible');

                // Show success feedback
                captureBtn.textContent = '‚úì';
                setTimeout(() => {
                    captureBtn.textContent = 'üì∑';
                }, 1500);

            } catch (err) {
                showError('ÁîªÂÉè„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + err.message);
            }
        }

        // Helper functions for drawing on capture canvas
        function drawGridOnCanvas(ctx, bounds) {
            const { x, y, width, height } = bounds;
            const gridSize = Math.min(width, height) / 10;
            for (let i = gridSize; i < width; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + height);
                ctx.stroke();
            }
            for (let i = gridSize; i < height; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, y + i);
                ctx.lineTo(x + width, y + i);
                ctx.stroke();
            }
        }

        function drawRulerOnCanvas(ctx, bounds) {
            const { x, y, width, height } = bounds;
            const spacing = Math.min(width, height) / 10;
            for (let i = 0; i < width; i += spacing / 5) {
                const tickHeight = (Math.abs(i % spacing) < 0.01) ? 40 : 20;
                ctx.beginPath();
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + tickHeight);
                ctx.stroke();
            }
            for (let i = 0; i < height; i += spacing / 5) {
                const tickWidth = (Math.abs(i % spacing) < 0.01) ? 40 : 20;
                ctx.beginPath();
                ctx.moveTo(x, y + i);
                ctx.lineTo(x + tickWidth, y + i);
                ctx.stroke();
            }
        }

        function drawQuartersOnCanvas(ctx, bounds) {
            const { x, y, width, height } = bounds;
            ctx.beginPath();
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width / 2, y + height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y + height / 2);
            ctx.lineTo(x + width, y + height / 2);
            ctx.stroke();
        }

        function drawQuartersGridOnCanvas(ctx, bounds) {
            const { x, y, width, height } = bounds;
            // Draw 3 vertical lines (creating 4 columns)
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x + (width * i / 4), y);
                ctx.lineTo(x + (width * i / 4), y + height);
                ctx.stroke();
            }
            // Draw 3 horizontal lines (creating 4 rows)
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x, y + (height * i / 4));
                ctx.lineTo(x + width, y + (height * i / 4));
                ctx.stroke();
            }
        }

        function drawThirdsOnCanvas(ctx, bounds) {
            const { x, y, width, height } = bounds;
            ctx.beginPath();
            ctx.moveTo(x + width / 3, y);
            ctx.lineTo(x + width / 3, y + height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + width * 2 / 3, y);
            ctx.lineTo(x + width * 2 / 3, y + height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y + height / 3);
            ctx.lineTo(x + width, y + height / 3);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y + height * 2 / 3);
            ctx.lineTo(x + width, y + height * 2 / 3);
            ctx.stroke();
        }

        function drawGoldenRatioOnCanvas(ctx, bounds) {
            const { x, y, width, height } = bounds;
            const phi = 1.618;
            ctx.beginPath();
            ctx.moveTo(x + width / phi, y);
            ctx.lineTo(x + width / phi, y + height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + width - width / phi, y);
            ctx.lineTo(x + width - width / phi, y + height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y + height / phi);
            ctx.lineTo(x + width, y + height / phi);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y + height - height / phi);
            ctx.lineTo(x + width, y + height - height / phi);
            ctx.stroke();
        }

        function showError(message) {
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        // Event listeners
        scaleTypeSelect.addEventListener('change', drawScale);
        formatSelect.addEventListener('change', drawScale);
        colorInput.addEventListener('input', drawScale);
        opacityInput.addEventListener('input', drawScale);

        toggleControlsBtn.addEventListener('click', () => {
            controlsDiv.classList.add('hidden');
            openControlsBtn.classList.add('visible');
        });

        openControlsBtn.addEventListener('click', () => {
            controlsDiv.classList.remove('hidden');
            openControlsBtn.classList.remove('visible');
        });

        switchCameraBtn.addEventListener('click', () => {
            facingMode = facingMode === 'environment' ? 'user' : 'environment';
            initCamera();
        });

        captureBtn.addEventListener('click', captureImage);

        closePreviewBtn.addEventListener('click', () => {
            imagePreviewDiv.classList.remove('visible');
            previewImage.src = '';
        });

        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        window.addEventListener('resize', resizeOverlay);
        screen.orientation?.addEventListener('change', resizeOverlay);

        // Start the app
        initCamera();

        // Redraw scale periodically to keep it smooth
        setInterval(drawScale, 100);
    </script>
</body>
</html>
